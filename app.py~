print("[DIAG] app.py loaded")

import time
import os
import threading
os.environ["IMAGEMAGICK_BINARY"] = r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"

import streamlit as st
st.set_page_config(
    page_title="Multi-Niche Video Generator",
    page_icon="üé¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

"""Streamlit web interface for video generation system."""

import yaml
import json
from typing import Dict, List, Optional, Tuple
from Content_Engine.api_generator import ScriptGenerator
from Content_Engine.scene_generator import generate_scene_metadata
from Media_Handler.video_processor import VideoProcessor, StreamlitProglogLogger
from Media_Handler.video_logic import VideoLogic
import logging
from pathlib import Path
from utils.config_loader import load_config
import sys
from utils.trending_apis import get_google_trends, get_youtube_trends, get_twitter_trends
from utils.api_key_manager import get_api_key, save_api_key
from utils.music_apis import search_pixabay_music, fetch_youtube_audio_library_trending, epidemic_sound_note

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1E88E5;
        text-align: center;
        margin-bottom: 1rem;
    }
    .section-header {
        font-size: 1.5rem;
        color: #0D47A1;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }
    .card {
        padding: 1.5rem;
        border-radius: 0.5rem;
        background-color: #f8f9fa;
        box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        margin-bottom: 1rem;
    }
    .success-box {
        padding: 1rem;
        border-radius: 0.25rem;
        background-color: #d4edda;
        color: #155724;
        margin-bottom: 1rem;
    }
    .info-box {
        padding: 1rem;
        border-radius: 0.25rem;
        background-color: #cce5ff;
        color: #004085;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

# --- Scene Editor Helper ---
def scene_editor(scenes):
    """UI for editing scenes. Returns the edited scenes list."""
    edited_scenes = []
    for i, scene in enumerate(scenes):
        st.subheader(f"Scene {i+1}")
        edited = {}
        edited['scene_number'] = st.number_input(f"Scene Number", value=scene.get('scene_number', i+1), key=f"scene_number_{i}")
        edited['script'] = st.text_area(f"Script", value=scene.get('script', ''), key=f"scene_script_{i}")
        edited['background'] = st.text_input(f"Background", value=scene.get('background', ''), key=f"scene_bg_{i}")
        # Add more editable fields as needed
        edited_scenes.append(edited)
    return edited_scenes

def load_config(config_path: str = "config.yaml") -> dict:
    """Load configuration from YAML file."""
    try:
        with open(config_path, 'r') as file:
            return yaml.safe_load(file)
    except Exception as e:
        logger.error(f"Error loading config: {e}")
        st.error(f"Error loading config: {e}")
        if st.button("Retry Loading Config", key="retry_config"):
            st.rerun()
        return {}

def load_project(project_path: str) -> dict:
    """Load a saved project from JSON file."""
    try:
        with open(project_path, 'r') as file:
            return json.load(file)
    except Exception as e:
        logger.error(f"Error loading project: {e}")
        st.error(f"Error loading project: {e}")
        if st.button("Retry Loading Project", key="retry_project"):
            st.rerun()
        return {}

def save_project(project_data: dict, project_name: str) -> str:
    """Save project data to a JSON file."""
    try:
        os.makedirs("projects", exist_ok=True)
        project_path = f"projects/{project_name}.json"
        with open(project_path, 'w') as file:
            json.dump(project_data, file, indent=2)
        return project_path
    except Exception as e:
        logger.error(f"Error saving project: {e}")
        st.error(f"Error saving project: {e}")
        if st.button("Retry Saving Project", key="retry_save_project"):
            st.rerun()
        return None

def generate_script(script_generator: ScriptGenerator, generation_method: str) -> Tuple[str, Dict]:
    """Generate script based on selected method."""
    script_text = ""
    metadata = {}
    try:
        if generation_method == "AI Generation":
            col1, col2 = st.columns([3, 1])
            with col1:
                ai_provider = st.selectbox(
                    "Select AI Provider:",
                    options=["OpenAI", "Anthropic", "Llama", "Custom"],
                    index=0
                )
                topic = st.text_input("Enter Topic:")
                if st.button("Generate Script"):
                    try:
                        script_text, metadata = script_generator.generate(topic, ai_provider)
                        st.session_state.script_text = script_text
                        st.session_state.script_metadata = metadata
                        st.success("Script generated successfully!")
                    except Exception as e:
                        logger.error(f"Failed to generate script: {e}")
                        st.error(f"Failed to generate script: {e}")
                        if st.button("Retry Script Generation", key="retry_script_gen"):
                            st.rerun()
            with col2:
                st.markdown("### Script Writing Tips")
                st.markdown("- Keep scenes concise and focused")
                st.markdown("- Include visual cues in [brackets]")
                st.markdown("- Use engaging hooks at the beginning")
                st.markdown("- Consider your target audience")
                st.markdown("### Example Format")
                st.code("""
Scene 1: Intro
[Show cityscape at sunset]
Welcome to our guide on...

Scene 2: Main Point
[Display chart showing data]
The key insight here is...
                """)
        else:
            st.markdown("""
**Paste your script in the following format (copy-paste ready):**

```json
[
  {
    "scene_number": 1,
    "title": "Introduction",
    "background": "Show cityscape at sunset with a mosque in the foreground, modern, clean design, minimalist, professional lighting, high quality, 4k",
    "script": "Welcome! Today we explore the Five Pillars of Islam‚Äîthe foundation of a Muslim's faith and practice.",
    "duration": 6
  },
  {
    "scene_number": 2,
    "title": "Shahada",
    "background": "Show a family gathered for prayer in a cozy home.",
    "script": "The first pillar is Shahada, the declaration of faith.",
    "duration": 5
  }
]
```

- Each scene **must** have `scene_number`, `title`, and `script` fields.
- Only the `script` field is used for voiceover/subtitles. It must be unique per scene and not contain background/visual descriptions.
- No two scenes can have the same `scene_number`.
- This matches the format returned by AI APIs.
""")
            script_text = st.text_area("Paste or write your script below:")
            valid = True
            error_msgs = []
            scenes = []
            if script_text.strip():
                try:
                    parsed = json.loads(script_text)
                    if not isinstance(parsed, list):
                        valid = False
                        error_msgs.append("Script must be a JSON array of scenes.")
                    else:
                        seen_numbers = set()
                        for idx, s in enumerate(parsed):
                            if not isinstance(s, dict):
                                valid = False
                                error_msgs.append(f"Scene {idx+1} is not an object.")
                                continue
                            for field in ["scene_number", "title", "script"]:
                                if field not in s or not str(s[field]).strip():
                                    valid = False
                                    error_msgs.append(f"Scene {idx+1} is missing required field: '{field}'.")
                            # scene_number uniqueness
                            if 'scene_number' in s:
                                if s['scene_number'] in seen_numbers:
                                    valid = False
                                    error_msgs.append(f"Duplicate scene_number: {s['scene_number']}.")
                                seen_numbers.add(s['scene_number'])
                            # script must be unique and not similar to title or background
                            script = s.get('script', '').strip()
                            title = s.get('title', '').strip().lower()
                            background = s.get('background', '').strip().lower()
                            if script.lower() == title or script.lower() == background:
                                valid = False
                                error_msgs.append(f"Scene {idx+1} 'script' must not duplicate the title or background.")
                            if script.lower().startswith(('show ', 'display ', 'background', 'visual')):
                                valid = False
                                error_msgs.append(f"Scene {idx+1} 'script' looks like a background/visual description.")
                            if len(script) < 2:
                                valid = False
                                error_msgs.append(f"Scene {idx+1} 'script' is too short.")
                        scenes = parsed if valid else []
                except Exception as e:
                    valid = False
                    error_msgs = [f"Script is not valid JSON: {e}"]
            if not valid:
                for msg in error_msgs:
                    st.error(msg)
            if st.button("Save Script"):
                if valid and scenes:
                    st.session_state.script_text = script_text
                    st.session_state.script_metadata = {"scenes": scenes}
                    st.success("Script saved successfully!")
                else:
                    st.error("Script format is invalid. Please fix errors before saving.")
            return script_text, {"scenes": scenes if valid else []}
        return script_text, metadata
    except Exception as e:
        logger.error(f"Script generation error: {e}")
        st.error(f"Script generation error: {e}")
        if st.button("Retry Script Generation", key="retry_script_gen2"):
            st.rerun()
        return "", {}

def scene_editor(scenes: List[Dict]) -> List[Dict]:
    """Interactive scene editor for modifying scene metadata."""
    edited_scenes = scenes.copy()
    
    st.markdown("### Scene Editor")
    st.info("Edit each scene to customize your video. You can modify text, duration, and visual elements.")
    
    for i, scene in enumerate(edited_scenes):
        with st.expander(f"Scene {i+1}"):
            st.markdown("**Scene Narration/Subtitle** (words to be spoken and shown as subtitles)")
            narration = scene.get('script', '')
            narration_input = st.text_area("Narration/Subtitle", narration, key=f"scene_script_{i}")
            edited_scenes[i]['script'] = narration_input

            st.markdown("**Background Source**")
            bg_option = st.selectbox(
                "Choose background type",
                ["Upload", "API Search", "Color/System"],
                key=f"bg_type_{i}"
            )
            bg_value = None
            if bg_option == "Upload":
                uploaded_file = st.file_uploader("Upload background image", type=["jpg", "jpeg", "png"], key=f"bg_upload_{i}")
                if uploaded_file:
                    # Save the uploaded file to a temp location and store path
                    import tempfile
                    temp_dir = tempfile.gettempdir()
                    file_path = os.path.join(temp_dir, uploaded_file.name)
                    with open(file_path, "wb") as f:
                        f.write(uploaded_file.getbuffer())
                    bg_value = {"type": "upload", "value": file_path}
            elif bg_option == "API Search":
                search_term = st.text_input("Image search term (Pixabay/Unsplash)", value=scene.get('background', {}).get('search', ''), key=f"bg_api_search_{i}")
                # Placeholder for UI: In production, show thumbnails from API
                bg_value = {"type": "api", "value": search_term}
            elif bg_option == "Color/System":
                color = st.color_picker("Pick a color", value=scene.get('background', {}).get('color', '#000000'), key=f"bg_color_{i}")
                system_bg = st.selectbox("Or select system background", ["None", "Blur", "Gradient", "Pattern1", "Pattern2"], key=f"bg_sys_{i}")
                bg_value = {"type": "color", "value": color, "system": system_bg}
            if bg_value:
                edited_scenes[i]['background'] = bg_value

            # Additional fields
            edited_scenes[i]['duration'] = st.number_input("Duration (seconds)", min_value=1.0, max_value=60.0, value=float(scene.get('duration', 5)), step=0.5, key=f"scene_duration_{i}")
            edited_scenes[i]['transition'] = st.selectbox("Transition", ["fade", "cut", "slide", "none"], index=["fade", "cut", "slide", "none"].index(scene.get('transition', 'fade')), key=f"scene_transition_{i}")
            edited_scenes[i]['speaker'] = st.text_input("Speaker", value=scene.get('speaker', ''), key=f"scene_speaker_{i}")
            edited_scenes[i]['emotion'] = st.selectbox("Emotion", ["neutral", "happy", "sad", "excited", "angry", "surprised", "fearful"], index=["neutral", "happy", "sad", "excited", "angry", "surprised", "fearful"].index(scene.get('emotion', 'neutral')), key=f"scene_emotion_{i}")
            edited_scenes[i]['visual_prompt'] = st.text_area("Visual Prompt (for AI image gen)", value=scene.get('visual_prompt', ''), key=f"scene_visual_prompt_{i}")
            edited_scenes[i]['audio_effects'] = st.text_input("Audio Effects (comma separated)", value=scene.get('audio_effects', ''), key=f"scene_audio_effects_{i}")
            edited_scenes[i]['sound_effects'] = st.text_input("Sound Effects (comma separated)", value=scene.get('sound_effects', ''), key=f"scene_sound_effects_{i}")
            edited_scenes[i]['subtitle_style'] = st.selectbox("Subtitle Style", ["default", "bold", "large", "italic", "highlight"], index=["default", "bold", "large", "italic", "highlight"].index(scene.get('subtitle_style', 'default')), key=f"scene_subtitle_style_{i}")
            edited_scenes[i]['voice_style'] = st.selectbox("Voice Style", ["male", "female", "child", "robotic", "narrator"], index=["male", "female", "child", "robotic", "narrator"].index(scene.get('voice_style', 'male')), key=f"scene_voice_style_{i}")
            edited_scenes[i]['notes'] = st.text_area("Internal Notes", value=scene.get('notes', ''), key=f"scene_notes_{i}")
    
    return edited_scenes

def script_input_section(prepopulate=None):
    st.header("Video Script Input")
    st.markdown("""
    Paste the entire script below in the following JSON format:
    ```json
    {
      "title": "Video Title",
      "description": "Short description...",
      "author": "...",
      "category": "Education",
      "language": "en",
      "tags": ["tag1", "tag2"],
      "scenes": [
        {"scene_number": 1, "script": "...", "background": {"type": "color", "value": "#000000"}},
        {"scene_number": 2, "script": "...", "background": {"type": "api", "value": "office"}}
      ]
    }
    ```
    - Only `scene_number`, `script`, and `background` are required per scene initially.
    - All other fields can be added/edited in the Scene section.
    """)
    script_text = st.text_area("Paste your script JSON here", height=300, key="script_json_input", value=prepopulate if prepopulate else "")
    if st.button("Validate & Continue", key="validate_script_btn"):
        import json
        try:
            data = json.loads(script_text)
            required_globals = ["title", "scenes"]
            for g in required_globals:
                if g not in data:
                    st.error(f"Missing required global field: {g}")
                    return None
            if not isinstance(data['scenes'], list) or not data['scenes']:
                st.error("'scenes' must be a non-empty list.")
                return None
            seen_numbers = set()
            for idx, scene in enumerate(data['scenes']):
                if 'scene_number' not in scene or 'script' not in scene or 'background' not in scene:
                    st.error(f"Scene {idx+1} missing required fields.")
                    return None
                if scene['scene_number'] in seen_numbers:
                    st.error(f"Duplicate scene_number: {scene['scene_number']}")
                    return None
                seen_numbers.add(scene['scene_number'])
            st.session_state['script_data'] = data
            st.session_state['scenes'] = data['scenes']
            st.session_state['current_step'] = 2
            st.success("Script validated! Proceed to Music selection.")
            st.rerun()
        except Exception as e:
            st.error(f"Invalid JSON: {e}")
    return st.session_state.get('script_data')

def voice_and_style_selector_tts(default_lang='en', default_speed=1.0):
    import streamlit as st
    from utils.config_loader import load_config
    import yaml, os
    config = load_config()
    tts_config = config.get('tts', {}) if config else {}
    def_lang = tts_config.get('language', default_lang)
    def_speed = float(tts_config.get('speed', default_speed))
    st.markdown('### Voice and Style Selection')
    st.info('Configure Text-to-Speech (TTS) for your video.')
    tts_lang = st.text_input('TTS Language Code', value=def_lang, help='e.g. en, ur, fr, etc.')
    tts_speed = st.slider('TTS Speed', min_value=0.5, max_value=2.0, value=def_speed, step=0.1, help='1.0 = normal, other values set slow mode')
    st.info(f'Current config: language = {tts_lang}, speed = {tts_speed}')
    if tts_lang != def_lang or tts_speed != def_speed:
        config['tts'] = {'language': tts_lang, 'speed': tts_speed}
        config_path = os.path.join(os.path.dirname(__file__), 'config.yaml')
        with open(config_path, 'w') as f:
            yaml.dump(config, f)
        st.success('TTS config updated!')
    # Style selection (reuse your style_selector logic here if needed)
    return tts_lang, tts_speed

def style_selector(prepopulate=None, return_name=False) -> dict:
    """Enhanced video style selector with preview and customization."""
    styles = {
        "modern": {"description": "Clean, minimalist design with smooth transitions", "color_scheme": "blue-white", "transitions": ["fade", "dissolve"], "preview_image": "templates/style_previews/modern.jpg"},
        "corporate": {"description": "Professional and polished look", "color_scheme": "navy-gray", "transitions": ["fade", "wipe"], "preview_image": "templates/style_previews/corporate.jpg"},
        "creative": {"description": "Dynamic and artistic elements", "color_scheme": "purple-orange", "transitions": ["zoom", "slide"], "preview_image": "templates/style_previews/creative.jpg"},
        "tech": {"description": "High-tech, digital aesthetic", "color_scheme": "black-green", "transitions": ["glitch", "fade"], "preview_image": "templates/style_previews/tech.jpg"},
        "casual": {"description": "Friendly and approachable style", "color_scheme": "yellow-blue", "transitions": ["slide", "wipe"], "preview_image": "templates/style_previews/casual.jpg"}
    }
    style_names = list(styles.keys())
    default_idx = 0
    if prepopulate and isinstance(prepopulate, dict) and 'base_style' in prepopulate:
        try:
            default_idx = style_names.index(prepopulate['base_style'])
        except Exception:
            pass
    selected_style = st.selectbox("Select Video Style", style_names, index=default_idx)
    style_details = styles.get(selected_style, {})
    st.markdown(f"**Selected Style:** {selected_style.title()}")
    st.markdown(f"*{style_details.get('description','')}*")
    # Customization options (add more as needed)
    # Restore original video quality selector
    quality_options = [
        ("HD (1280x720)", "HD"),
        ("Full HD (1920x1080)", "FHD"),
        ("4K (3840x2160)", "4K")
    ]
    quality_labels = [q[0] for q in quality_options]
    quality_keys = [q[1] for q in quality_options]
    default_quality_idx = 1  # Default to Full HD
    selected_quality_label = st.selectbox(
        "Video Quality (Resolution)",
        options=quality_labels,
        index=default_quality_idx
    )
    selected_quality = quality_keys[quality_labels.index(selected_quality_label)]
    color_scheme = st.selectbox("Color Scheme", [style_details.get('color_scheme', 'default')], index=0)
    transition = st.selectbox("Transition", style_details.get('transitions', ['fade']), index=0)
    config = {
        "base_style": selected_style,
        "color_scheme": color_scheme,
        "transition": transition,
        "video_quality": selected_quality
    }
    if return_name:
        return selected_style, config
    return config

def music_selection_ui(prefix: str) -> dict:
    music_file = None
    music_url = None
    music_results = []
    music_volume = st.slider(f'Music Volume (relative to voice) ({prefix})', min_value=0.0, max_value=1.0, value=0.1, step=0.01, key=f'music_volume_{prefix}')
    music_option = st.radio(f'Choose music source ({prefix}):', ['None', 'Manual Upload', 'Pixabay Music (Free)', 'YouTube Audio Library (Trending)', 'Epidemic Sound (Paid)'], key=f'music_option_{prefix}')
    if music_option == 'Manual Upload':
        music_file = st.file_uploader(f'Upload your own music/SFX ({prefix}) (mp3, wav)', type=['mp3', 'wav'], key=f'music_upload_{prefix}')
        if music_file:
            st.audio(music_file)
    elif music_option == 'Pixabay Music (Free)':
        pixabay_key = st.text_input(f'Pixabay API Key ({prefix}):', value=get_api_key('pixabay_music'), type='password', key=f'pixabay_music_key_{prefix}')
        if st.button(f'Save Pixabay API Key ({prefix})'):
            save_api_key('pixabay_music', pixabay_key)
            st.success(f'Pixabay API Key saved!')
        query = st.text_input(f'Search Pixabay Music ({prefix}):', value='trending', key=f'pixabay_music_query_{prefix}')
        if st.button(f'Search Pixabay Music ({prefix})'):
            music_results = search_pixabay_music(pixabay_key, query)
        if music_results:
            for idx, m in enumerate(music_results):
                st.markdown(f"**{m['title']}** by {m['user']} [{m['duration']}s]")
                st.audio(m['url'])
                if st.button(f"Select: {m['title']} ({prefix})", key=f"select_pixabay_{idx}_{prefix}"):
                    music_url = m['url']
    elif music_option == 'YouTube Audio Library (Trending)':
        yt_trending = fetch_youtube_audio_library_trending()
        for idx, m in enumerate(yt_trending):
            st.markdown(f"**{m['title']}** [YouTube Audio Library]")
            st.markdown(f"[Download Link]({m['url']})")
            if st.button(f"Select: {m['title']} ({prefix})", key=f"select_ytlib_{idx}_{prefix}"):
                music_url = m['url']
    elif music_option == 'Epidemic Sound (Paid)':
        st.warning(epidemic_sound_note())
        music_file = st.file_uploader(f'Upload Epidemic Sound music ({prefix}) (after download)', type=['mp3', 'wav'], key=f'epidemic_upload_{prefix}')
        if music_file:
            st.audio(music_file)
    else:
        st.info(f'No background music will be added ({prefix}).')
    return {'mode': music_option, 'file': music_file, 'url': music_url, 'volume': music_volume}

def process_video_generation(
    scenes: List[Dict], 
    video_processor: VideoProcessor,
    video_logic_handler: VideoLogic,
    style_config: Dict = None
) -> None:
    print("[DIAG] process_video_generation called")
    print(f"[DIAG] scenes: {scenes}")
    print(f"[DIAG] video_processor: {video_processor}")
    print(f"[DIAG] video_logic_handler: {video_logic_handler}")
    print(f"[DIAG] style_config: {style_config}")
    if not scenes:
        print("[DIAG] No scenes available for processing. Returning None.")
        st.error("No scenes available for processing.")
        return
        
    # Create a placeholder for progress bar
    progress_placeholder = st.empty()
    progress_bar = progress_placeholder.progress(0)
    
    # Create status text
    status_text = st.empty()
    
    try:
        with st.spinner("Generating your video..."):
            # Phase 1: Scene Processing
            status_text.markdown("**Processing scenes...**")
            processed_scenes = []
            
            # Convert style_config to a proper style dictionary
            style_dict = {
                "style_name": style_config.get("base_style", "modern"),
                "font": style_config.get("font", "Arial"),
                "font_size": style_config.get("font_size", 36),
                "color": style_config.get("color", "#FFFFFF"),
                "background_color": style_config.get("background_color", "#000000"),
                "aspect_ratio": style_config.get("aspect_ratio", "16:9"),
                "resolution": style_config.get("resolution", (1920, 1080)),
                "fps": style_config.get("fps", 30),
                "bitrate": style_config.get("bitrate", "8M"),
                "use_intro": st.checkbox("Include Intro Video (if available)", value=False),
                "use_outro": st.checkbox("Include Outro Video (if available)", value=False),
                "use_logo": st.checkbox("Include Logo Overlay (if available)", value=False)
            }
            
            music_info = st.session_state.get('music_for_video', None)
            music_arg = None
            music_volume = 0.1
            if music_info:
                music_volume = music_info.get('volume', 0.1)
                if music_info['mode'] in ['manual', 'epidemic'] and music_info.get('file'):
                    music_arg = music_info['file']
                elif music_info['mode'] in ['pixabay', 'ytlib'] and music_info.get('url'):
                    music_arg = music_info['url']
            
            for i, scene in enumerate(scenes):
                processed = video_logic_handler.process_scene(
                    scene, 
                    style_dict,
                    None
                )
                if processed:
                    processed_scenes.append(processed)
                progress_bar.progress((i + 1) / (len(scenes) * 2))  # First half of progress
            
            status_text.markdown("‚úÖ Scene processing complete!")
            
            # Phase 2: Video Compilation
            status_text.markdown("**Compiling final video...**")
            
            # Create a Streamlit progress bar for video rendering
            video_progress_bar = st.progress(0, text="Rendering video...")
            style_dict["streamlit_logger"] = StreamlitProglogLogger(lambda: video_progress_bar)
            
            print("[DIAG] About to call video_processor.compile_video")
            output_file = video_processor.compile_video(
                scenes=processed_scenes,
                output_name=f"{style_config.get('base_style', 'video')}_{int(time.time())}.mp4",
                additional_settings=style_dict
            )
            print(f"[DIAG] video_processor.compile_video returned: {output_file}")
            
            for i in range(len(scenes)):
                progress_bar.progress((len(scenes) + i + 1) / (len(scenes) * 2))  # Second half of progress
                time.sleep(0.1)  # Simulate processing time
                
            status_text.markdown("‚úÖ Video compilation complete!")
            progress_bar.progress(1.0)
            
            # Clear progress bar after rendering
            video_progress_bar.empty()
            
            # Display completion message and video
            retry_count = 0
            max_retries = 5
            retry_delay = 1  # seconds
            while output_file and not os.path.exists(output_file) and retry_count < max_retries:
                time.sleep(retry_delay)
                retry_count += 1

            output_dir = os.path.dirname(output_file) if output_file else None
            if output_file and os.path.exists(output_file):
                st.success(f"\U0001F389 Your video has been successfully generated!\n\nSaved at: {output_file}")
                st.video(output_file)
                # Add download button
                with open(output_file, "rb") as file:
                    st.download_button(
                        label="Download Video",
                        data=file,
                        file_name=os.path.basename(output_file),
                        mime="video/mp4"
                    )
            elif output_dir and os.path.exists(output_dir):
                # Fallback: show most recent video in output directory if exists
                import glob
                video_files = sorted(
                    glob.glob(os.path.join(output_dir, '*.mp4')),
                    key=os.path.getmtime,
                    reverse=True
                )
                if video_files:
                    latest_video = video_files[0]
                    st.warning(f"Video not found at expected path, showing latest video in directory: {latest_video}")
                    st.video(latest_video)
                    with open(latest_video, "rb") as file:
                        st.download_button(
                            label="Download Latest Video",
                            data=file,
                            file_name=os.path.basename(latest_video),
                            mime="video/mp4"
                        )
                else:
                    st.error(f"Video generation completed, but the output file was not found.\nExpected directory: {output_dir}")
            else:
                st.error("Video generation completed, but the output file was not found. Output directory does not exist.")
                
    except Exception as e:
        print(f"[DIAG] Exception in process_video_generation: {e}")
        logger.error(f"Error generating video: {str(e)}")
        st.error(f"Error generating video: {str(e)}")
        
    finally:
        # Always clear the progress bar and status text
        progress_placeholder.empty()
        status_text.empty()

def main() -> None:
    """Main application function."""
    st.title("üé¨ Multi-Niche Video Generator")
    # Stepper logic
    if 'current_step' not in st.session_state:
        st.session_state['current_step'] = 1
    # Always get the latest step value right before step logic
    step = st.session_state['current_step']

    # Sidebar Navigation
    st.sidebar.title("Navigation")
    steps = [
        (1, "Script Input"),
        (2, "Scene Editing"),
        (3, "Voice & Music"),
        (4, "Video Generation")
    ]
    for idx, label in steps:
        if st.sidebar.button(label, key=f"sidebar_nav_{idx}"):
            st.session_state['current_step'] = idx
            st.rerun()
    st.sidebar.markdown(f"**Current Step:** {steps[st.session_state['current_step']-1][1]}")

    # Step 1: Script Input
    if step == 1:
        # --- Choose Script Input Mode: Manual or API ---
        script_input_mode = st.radio(
            "How do you want to provide your script?",
            ["Manual Entry (Paste/Write)", "Fetch from API (Auto)"]
        )
        if script_input_mode == "Manual Entry (Paste/Write)":
            # --- Sample Script Section (show at the top for easy copy) ---
            st.markdown("""
            **Sample Script Format (Copy & Edit):**
            ```json
            {
              "title": "Sample Video Title",
              "description": "A quick video about sample scenes.",
              "author": "Your Name",
              "category": "Education",
              "language": "en",
              "tags": ["sample", "education", "demo"],
              "scenes": [
                {
                  "scene_number": 1,
                  "title": "Introduction",
                  "background": {"type": "color", "value": "#222244"},
                  "script": "Welcome! This is the intro scene.",
                  "duration": 5
                },
                {
                  "scene_number": 2,
                  "title": "Main Content",
                  "background": {"type": "api", "value": "office"},
                  "script": "Here we show the main content.",
                  "duration": 6
                }
              ]
            }
            ```
            - Paste your script below or edit the sample. Fields can be in JSON, YAML, or label:value format.
            - Only `scene_number`, `title`, `script`, and `background` are required per scene initially.
            """)
            # --- Ensure script_data is always defined ---
            script_data = st.session_state.get('script_data')
            if script_data is None:
                script_data = {}
            # --- Paste or Write Script Window (move to the top, before metadata fields) ---
            # Always keep script input in session state to survive reruns and step changes
            if 'script_text' not in st.session_state:
                st.session_state['script_text'] = script_data.get('script', '')
            full_script = st.text_area('Paste or Write Your Script Here', value=st.session_state['script_text'], height=250, key='script_input')
            st.session_state['script_text'] = full_script
        else:
            st.markdown('**Fetch Script from API**')
            api_url = st.text_input('API Endpoint URL', key='script_api_url')
            api_key = st.text_input('API Key (optional)', key='script_api_key', type='password')
            fetch_btn = st.button('Fetch Script', key='fetch_script_btn')
            script_data = st.session_state.get('script_data')
            if script_data is None:
                script_data = {}
            full_script = script_data.get('script', '')
            if fetch_btn and api_url:
                import requests
                headers = {'Authorization': f'Bearer {api_key}'} if api_key else {}
                try:
                    resp = requests.get(api_url, headers=headers, timeout=10)
                    resp.raise_for_status()
                    fetched = resp.text
                    st.success('Script fetched from API!')
                    full_script = fetched
                    st.session_state['script_data'] = {**script_data, 'script': fetched}
                except Exception as e:
                    st.error(f'Failed to fetch script: {e}')
        # (metadata fields now come after script input)
        meta_title = st.text_input('Video Title', value=script_data.get('title', ''), key='meta_title')
        meta_desc = st.text_area('Description', value=script_data.get('description', ''), key='meta_desc')
        meta_author = st.text_input('Author', value=script_data.get('author', ''), key='meta_author')
        meta_category = st.text_input('Category', value=script_data.get('category', ''), key='meta_category')
        meta_language = st.text_input('Language', value=script_data.get('language', ''), key='meta_language')
        meta_tags = st.text_input('Tags (comma separated)', value=','.join(script_data.get('tags', [])), key='meta_tags')
        # Logo uploader
        meta_logo = st.file_uploader('Upload Logo (PNG/JPG, transparent preferred)', type=['png', 'jpg', 'jpeg'], key='meta_logo')
        if meta_logo:
            st.session_state['meta_logo_bytes'] = meta_logo.read()
        # Watermark uploader
        meta_watermark = st.file_uploader('Upload Watermark (PNG/JPG, semi-transparent recommended)', type=['png', 'jpg', 'jpeg'], key='meta_watermark')
        if meta_watermark:
            st.session_state['meta_watermark_bytes'] = meta_watermark.read()
        meta_slogan = st.text_input('Slogan (optional)', value=script_data.get('slogan', ''), key='meta_slogan')
        meta_overlay_color = st.color_picker('Overlay Bar Color', value=script_data.get('overlay_color', '#222244'), key='meta_overlay_color')
        meta_animate = st.checkbox('Animate Overlay (slide in)', value=script_data.get('animate', False), key='meta_animate')
        # --- Auto-extract metadata from script if fields are empty ---
        import re
        def extract_metadata_from_script(text):
            meta = {}
            # Smarter patterns: allow JSON, YAML, and loose label: value lines
            import json, re
            # Try JSON parse
            try:
                data = json.loads(text)
                for k in ['title','description','author','category','language','tags']:
                    if k in data:
                        meta[k] = data[k]
                if 'tags' in meta and isinstance(meta['tags'], str):
                    meta['tags'] = [t.strip() for t in re.split(r'[;,]', meta['tags']) if t.strip()]
                return meta
            except Exception:
                pass
            # Try YAML parse (if PyYAML installed)
            try:
                import yaml
                data = yaml.safe_load(text)
                for k in ['title','description','author','category','language','tags']:
                    if k in data:
                        meta[k] = data[k]
                if 'tags' in meta and isinstance(meta['tags'], str):
                    meta['tags'] = [t.strip() for t in re.split(r'[;,]', meta['tags']) if t.strip()]
                return meta
            except Exception:
                pass
            # Fallback: regex for label: value (robust to whitespace, dash, colon, etc)
            patterns = {
                'title': r'(?im)^\s*(?:title|video title)\s*[:\-\|]\s*(.+)$',
                'author': r'(?im)^\s*(?:author|by)\s*[:\-\|]\s*(.+)$',
                'description': r'(?im)^\s*(?:description|desc)\s*[:\-\|]\s*(.+)$',
                'category': r'(?im)^\s*(?:category|topic)\s*[:\-\|]\s*(.+)$',
                'language': r'(?im)^\s*(?:language|lang)\s*[:\-\|]\s*(.+)$',
                'tags': r'(?im)^\s*(?:tags?)\s*[:\-\|]\s*(.+)$',
            }
            for key, pat in patterns.items():
                m = re.search(pat, text)
                if m:
                    meta[key] = m.group(1).strip()
            if 'tags' in meta:
                meta['tags'] = [t.strip() for t in re.split(r'[;,]', meta['tags']) if t.strip()]
            return meta
        # Only autofill if fields are empty
        auto_meta = extract_metadata_from_script(full_script)
        # Update only if the field is empty in UI
        meta_title = meta_title or auto_meta.get('title', '')
        meta_author = meta_author or auto_meta.get('author', '')
        meta_desc = meta_desc or auto_meta.get('description', '')
        meta_category = meta_category or auto_meta.get('category', '')
        meta_language = meta_language or auto_meta.get('language', '')
        meta_tags = meta_tags or ','.join(auto_meta.get('tags', []))
        # UI hint for user
        st.caption('üí° You can paste JSON, YAML, or label:value lines. Metadata will be auto-filled if fields are left empty.')
        # Store script and (possibly updated) meta in session state
        st.session_state['script_data'] = {
            **script_data,
            'title': meta_title,
            'description': meta_desc,
            'author': meta_author,
            'category': meta_category,
            'language': meta_language,
            'tags': [t.strip() for t in meta_tags.split(',') if t.strip()],
            'slogan': meta_slogan,
            'overlay_color': meta_overlay_color,
            'animate': meta_animate,
            'script': full_script,
            'scenes': script_data.get('scenes', [])
        }
        col1, col2 = st.columns([1, 1])
        with col2:
            st.write('Raw script input:', repr(full_script))
            if st.button("‚û°Ô∏è Continue to Scene Editing", key="to_scene_editing"):
                import json
                try:
                    # Always use the latest script from session state
                    data = json.loads(st.session_state['script_text'])
                    required_globals = ["title", "scenes"]
                    for g in required_globals:
                        if g not in data:
                            st.error(f"Missing required global field: {g}")
                            return
                    if not isinstance(data['scenes'], list) or not data['scenes']:
                        st.error("'scenes' must be a non-empty list.")
                        return
                    seen_numbers = set()
                    for idx, scene in enumerate(data['scenes']):
                        if 'scene_number' not in scene or 'script' not in scene or 'background' not in scene:
                            st.error(f"Scene {idx+1} missing required fields.")
                            return
                        if scene['scene_number'] in seen_numbers:
                            st.error(f"Duplicate scene_number: {scene['scene_number']}")
                            return
                        seen_numbers.add(scene['scene_number'])
                    st.session_state['script_data'] = data
                    st.session_state['scenes'] = data['scenes']
                    st.session_state['current_step'] = 2
                    st.success("Script validated! Proceed to Scene Editing.")
                    st.rerun()
                except Exception as e:
                    st.error(f"Invalid JSON: {e}\n\nPlease make sure you are not including extra spaces, invisible characters, or that your script is not empty. If you pasted from Word or a web page, try pasting as plain text.")
        with col1:
            if st.button("üíæ Save Script", key="save_script_btn"):
                import json
                try:
                    data = json.loads(st.session_state['script_text'])
                    required_globals = ["title", "scenes"]
                    for g in required_globals:
                        if g not in data:
                            st.error(f"Missing required global field: {g}")
                            return
                    if not isinstance(data['scenes'], list) or not data['scenes']:
                        st.error("'scenes' must be a non-empty list.")
                        return
                    seen_numbers = set()
                    for idx, scene in enumerate(data['scenes']):
                        if 'scene_number' not in scene or 'script' not in scene or 'background' not in scene:
                            st.error(f"Scene {idx+1} missing required fields.")
                            return
                        if scene['scene_number'] in seen_numbers:
                            st.error(f"Duplicate scene_number: {scene['scene_number']}")
                            return
                        seen_numbers.add(scene['scene_number'])
                    st.session_state['script_data'] = data
                    st.session_state['scenes'] = data['scenes']
                    st.success("Script saved!")
                except Exception as e:
                    st.error(f"Invalid JSON: {e}")
        st.markdown('---')
        st.markdown('**Tip:** The API endpoint must return a JSON with a `scenes` array as shown above.')
        return
    # Step 2: Scene Editing
    elif step == 2:
        st.header("Step 2: Scene Editing")
        scenes = st.session_state.get('scenes', [])
        edited_scenes = scene_editor(scenes)
        if st.button("Save Scene Edits", key="save_scene_edits"):
            st.session_state['scenes'] = edited_scenes
            st.success("Scenes saved!")
        col1, col2 = st.columns([1,1])
        with col1:
            if st.button("Back to Script Input", key="back_to_script_input"):
                st.session_state['current_step'] = 1
                st.rerun()
        with col2:
            if st.button("Continue to Voice & Music", key="to_voice_music"):
                st.session_state['current_step'] = 3
                st.rerun()

    # Step 3: Voice & Music
    elif step == 3:
        st.header("Step 3: Voice Over & Music")
        tts_lang, tts_speed = voice_and_style_selector_tts()
        music_config = music_selection_ui("global")
        if st.button("Save Voice & Music Config", key="save_voice_music"):
            st.session_state['music_config'] = music_config
            st.session_state['tts_lang'] = tts_lang
            st.session_state['tts_speed'] = tts_speed
            st.success("Voice & Music settings saved!")
        col1, col2 = st.columns([1,1])
        with col1:
            if st.button("Back to Scene Editing", key="back_to_scene_editing"):
                st.session_state['current_step'] = 2
                st.rerun()
        with col2:
            if st.button("Continue to Video Generation", key="to_video_generation"):
                st.session_state['current_step'] = 4
                st.rerun()

    # Step 4: Video Generation
    elif step == 4:
        st.header("Step 4: Video Generation")
        style_name, style_config = style_selector(return_name=True)
        st.session_state['selected_style_name'] = style_name
        st.session_state['selected_style_config'] = style_config
        script_data = st.session_state.get('script_data', {})
        scenes = st.session_state.get('scenes', [])
        video_processor = VideoProcessor()
        video_logic_handler = VideoLogic()
        col1, col2 = st.columns([1,1])
        with col1:
            if st.button("Back to Voice & Music", key="back_to_voice_music"):
                st.session_state['current_step'] = 3
                st.rerun()
        with col2:
            if st.button("Generate Video", key="generate_video_btn_final"):
                # Save to temp file and show in app, not permanent folder
                import tempfile
                temp_video_file = tempfile.NamedTemporaryFile(delete=False, suffix='.mp4')
                temp_video_path = temp_video_file.name
                temp_video_file.close()
                # Call video generation logic, pass temp_video_path as output
                try:
                    video_path = video_logic_handler.process_video(
                        scenes,
                        audio_files=None,
                        style=style_config,
                        music_config=st.session_state.get('music_config', None)
                    )
                except TypeError:
                    # Fallback: call with output_path only if supported
                    video_path = video_processor.compile_video(
                        scenes,
                        audio_files=None,
                        style_name=style_name,
                        additional_settings=None,
                        output_name=temp_video_path
                    )
                if video_path and os.path.exists(video_path):
                    st.session_state['last_generated_video'] = video_path
                    st.success("Video generated!")
                else:
                    st.error("Video generation failed. No output file found.")
                st.rerun()
        # Show video if available
        import os
        import time
        def _schedule_temp_cleanup(path, delay=600):
            def _delete():
                time.sleep(delay)
                try:
                    if os.path.exists(path):
                        os.remove(path)
                except Exception:
                    pass
            threading.Thread(target=_delete, daemon=True).start()
        # --- Warn user if they try to decrease scene duration below voice-over length ---
        from moviepy.editor import AudioFileClip
        scenes = st.session_state.get('scenes', [])
        warnings = []
        for scene in scenes:
            audio_file = scene.get('audio_file')
            if audio_file and os.path.exists(audio_file):
                try:
                    audio_clip = AudioFileClip(audio_file)
                    audio_duration = audio_clip.duration
                    if scene.get('duration', 0) < audio_duration:
                        warnings.append(f"Scene {scene.get('scene_number','?')}: Duration increased to match voice-over length ({audio_duration:.2f}s). Cannot be set lower.")
                    audio_clip.close()
                except Exception:
                    pass
        if warnings:
            for w in warnings:
                st.warning(w)
        if 'last_generated_video' in st.session_state and os.path.exists(st.session_state['last_generated_video']):
            st.video(st.session_state['last_generated_video'])
            with open(st.session_state['last_generated_video'], "rb") as f:
                st.download_button("Download Video", f, file_name="generated_video.mp4")
            # Schedule auto cleanup (delete temp file after 10 minutes)
            _schedule_temp_cleanup(st.session_state['last_generated_video'], delay=600)

if __name__ == "__main__":
    main()
